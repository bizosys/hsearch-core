package --PACKAGE--;

import java.io.IOException;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Vector;
import java.util.concurrent.ConcurrentHashMap;

import java.util.concurrent.ConcurrentHashMap;
import com.bizosys.hsearch.federate.FederatedFacade;
import com.bizosys.hsearch.treetable.client.IHSearchPlugin;
import com.bizosys.hsearch.treetable.client.L;
import com.bizosys.hsearch.treetable.client.HSearchPluginPoints;

import com.bizosys.hsearch.hbase.HbaseLog;

public class HSearchPlugin--COLUMN-NAME-- implements IHSearchPlugin {
	
	static boolean DEBUG_ENABLED = HbaseLog.l.isDebugEnabled();
	
	//Take care of Thread Safety
	Vector<String> ids = new Vector<String>(65536, 256);
	Vector<String> values = new Vector<String>(65536, 256);
	Map<String, String> cols = new ConcurrentHashMap<String, String>(65536, 256);
	
	private static final ThreadLocal < StringBuilder > colbuilder = new ThreadLocal<StringBuilder>() {
	    @Override protected StringBuilder initialValue() {
            return new StringBuilder(1024);
	    }		
	};
	
	
	HSearchPluginPoints outputTypeCode = null;
	long counts = 0;
	double minValue = 0;
	double maxValue = 0;
	double avgValue = 0;

	@Override
	public void setOutputType(HSearchPluginPoints outputTypeCode) {
		this.outputTypeCode = outputTypeCode;
	}
	
	/**
	 * For each row, this is invoked. This is called if the findIds is called
	 * @return TRUE/FALSE whether it will be included in the result or not.
	 */
	public boolean onRowKey(--KEY_DATATYPE-- id) {
		//if ( DEBUG_ENABLED ) System.out.println( Thread.currentThread().getName() + " > ENTER HSearch Table Plugin onRowKey Id: " +  id);
		ids.add(id.toString());
		return true;
	}

	/**
	 * For each row, this is invoked. This is called if the findColumns is called
	 * @return TRUE/FALSE whether it will be included in the result or not.
	 */
	public boolean onRowCols(--ALL-COLS--) {
		String cell--CELL-MAX-MINUS-1--Str = cell--CELL-MAX-MINUS-1--.toString();
		StringBuilder sb = colbuilder.get();
		sb.delete(0, sb.capacity());
		sb.append(cell--CELL-MAX-MINUS-1--Str);
		cols.put(cell--CELL-MAX-MINUS-1--Str, sb.toString());
		return true;
	}

	/**
	 * For each row, this is invoked. This is called if the findKVs is called
	 * @return TRUE/FALSE whether it will be included in the result or not.
	 */
	public boolean onRowKeyValue(--KEY_DATATYPE-- k, --VAL_DATATYPE-- value) {
		StringBuilder sb = colbuilder.get();
		sb.delete(0, sb.capacity());
		String keyStr = k.toString();
		sb.append(keyStr).append('\t').append(value);
		cols.put(keyStr, sb.toString());
		return true;

	}
	
	/**
	 * For each row, this is invoked. This is called if the findValues is called
	 * @return TRUE/FALSE whether it will be included in the result or not.
	 */
	public boolean onRowValue(--VAL_DATATYPE-- value) {
		values.add(value.toString());
		return true;
	}
	
	/**
	 * Called when all items are processed
	 * Do not clear the ids here as the getUniqueRowKeys() are called after the onComplete.
	 */
	@Override
	public void onFilterationComplete() {
	}
	
	@Override
	public Collection<String> getUniqueMatchingDocumentIds() throws IOException {
		if ( this.ids.size() == 0 ) {
			return this.cols.keySet();
		} else {
			Set<String> unique = new HashSet<String>();
			unique.addAll(this.ids);
			return unique;		
		}
	}
	
	@Override
	public void cleanupValuesFromLastRun() {
		if ( null != ids ) this.ids.clear();
		if ( null != values ) this.values.clear();
		if ( null != cols ) this.cols.clear();
	}

	@Override
	public long getCount(List<FederatedFacade<String, String>.IRowId> matchedIds) {
		if ( this.ids.size() == 0 ) {
			return this.cols.size();
		} else {
			Set<String> unique = new HashSet<String>();
			unique.addAll(this.ids);
			return unique.size();
		}
	}
	
	@Override
	public double getMax(List<FederatedFacade<String, String>.IRowId> matchedIds) {
		return this.maxValue;
	}

	@Override
	public double getMin(List<FederatedFacade<String, String>.IRowId> matchedIds) {
		return this.minValue;
	}

	@Override
	public double getSum(List<FederatedFacade<String, String>.IRowId> matchedIds) {
		return this.avgValue;
	}
	
	@Override
	public double getAvg(List<FederatedFacade<String, String>.IRowId> matchedIds)  throws IOException {
		return 0;
	}
	
	@Override
	public void calculateFacets(Map<String, Integer> facets, 
			List<FederatedFacade<String, String>.IRowId> matchedIds ) throws IOException {
	}
	
	@Override
	public void getMatchingRowsWithTSV(List<FederatedFacade<String, String>.IRowId> matchedIds,
			Collection<String> container) throws IOException {
		
		String docId = null;
		for (FederatedFacade<String, String>.IRowId rowId: matchedIds) {
			docId = rowId.getDocId();
			if ( cols.containsKey( docId ) )  container.add(cols.get(docId));
		}
		cols.clear();
	}

	@Override
	public void getMatchingValuesWithTSV(List<FederatedFacade<String, String>.IRowId> matchedIds,
			Collection<String> container) throws IOException {
		
		container.addAll(values);
		
	}

	@Override
	public void getMatchingIdsAndValuesWithTSV(List<FederatedFacade<String, String>.IRowId> matchedIds,
			Collection<String> container) throws IOException {
		
		getMatchingRowsWithTSV(matchedIds, container);
		
	}
	
		
}